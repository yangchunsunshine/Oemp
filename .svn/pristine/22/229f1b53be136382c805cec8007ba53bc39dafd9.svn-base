package com.wb.component.computer.processManage.service.imp;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.log4j.Logger;
import org.hibernate.Criteria;
import org.hibernate.Query;
import org.springframework.stereotype.Service;
import org.springframework.transaction.interceptor.TransactionAspectSupport;

import com.wb.component.computer.processManage.service.IProcessManageService;
import com.wb.framework.commonDao.BaseDao;
import com.wb.framework.commonUtil.PageUtil;
import com.wb.framework.commonUtil.PageUtil.PageInfo;
import com.wb.model.entity.computer.processManage.MntNodeInfo;
import com.wb.model.entity.computer.processManage.MntOrgProcessHistory;
import com.wb.model.entity.computer.processManage.MntOrgProcessInfo;
import com.wb.model.entity.computer.processManage.MntProcessInfo;

/**
 * 流程管理Service层实现
 * 
 * @author 郑炜
 * @version [版本号, 2016-5-12]
 * @see [相关类/方法]
 * @since [产品/模块版本]
 */
@Service(value = "processManageService")
public class ProcessManageService extends BaseDao implements IProcessManageService
{
    /**
     * 日志服务
     */
    private static final Logger log = Logger.getLogger(ProcessManageService.class);
    
    @Override
    public PageUtil getProcessList(int mngId, String processName, String canUse, PageInfo info)
    {
        final StringBuffer sql = new StringBuffer();
        sql.append(" SELECT");
        sql.append(" pro.id AS proId,pro.mngId AS mngId,");
        sql.append(" pro.processName AS proName,mMem.orgName AS mngName,");
        sql.append(" pro.canUse AS canUse,pro.id AS opera");
        sql.append(" FROM mnt_processInfo pro");
        sql.append(" INNER JOIN mnt_member mMem");
        sql.append(" WHERE pro.mngId = mMem.id");
        sql.append(" AND pro.isDelete = 0 AND pro.mngId = ?");
        if (processName != null && !"".equals(processName))
        {
            sql.append(" AND pro.processName LIKE '%" + processName + "%'");
        }
        if (canUse != null && !"".equals(canUse))
        {
            sql.append(" AND pro.canUse = '" + canUse + "'");
        }
        return this.findPageBySqlQuery(sql.toString(), info.getPage(), info.getRows(), mngId);
    }
    
    @Override
    public int saveProcess(int mngId, MntProcessInfo processInfo)
    {
        try
        {
            boolean isRepeat = this.checkProcessNameRepeat(mngId, processInfo.getProcessName());
            if (isRepeat)
            {
                return 2;
            }
            processInfo.setMngId(mngId);
            processInfo.setCanUse(0);
            processInfo.setIsDelete(0);
            processInfo.setStamp(new Date());
            this.save(processInfo);
        }
        catch (Exception e)
        {
            e.printStackTrace();
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            return 1;
        }
        return 0;
    }
    
    @Override
    public boolean checkProcessNameRepeat(int mngId, String processName)
    {
        int num = 0;
        final StringBuffer sql = new StringBuffer();
        sql.append(" SELECT count(*) AS num");
        sql.append(" FROM mnt_processInfo");
        sql.append(" WHERE mngId=? AND processName = ?");
        final Query query = this.getSession().createSQLQuery(sql.toString());
        query.setParameter(0, mngId);
        query.setParameter(1, processName);
        query.setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP);
        final List<Map<String, Object>> list = query.list();
        for (Map<String, Object> map : list)
        {
            num = Integer.parseInt(map.get("num").toString());
        }
        if (num > 0)
        {
            return true;
        }
        return false;
    }
    
    @Override
    public boolean deleteProcess(MntProcessInfo processInfo)
    {
        try
        {
            this.deleteByPrimaryKey(MntProcessInfo.class, processInfo.getId());
        }
        catch (Exception e)
        {
            e.printStackTrace();
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            return false;
        }
        return true;
    }
    
    @Override
    public boolean saveNode(List<MntNodeInfo> nodes)
    {
        try
        {
            int processId = -1;
            for (MntNodeInfo node : nodes)
            {
                processId = node.getProcessId();
                node.setStamp(new Date());
                this.save(node);
            }
            int version = this.getNodeVersion(processId) + 1;
            for (int i = 0; i < nodes.size(); i++)
            {
                if (i == 0 && nodes.size() != 1)
                {
                    int beforeNodeId = -1;
                    int afterNodeId = nodes.get(i + 1).getId();
                    nodes.get(i).setBeforeNodeId(beforeNodeId);
                    nodes.get(i).setAfterNodeId(afterNodeId);
                    nodes.get(i).setVersion(version);
                    this.update(nodes.get(i));
                }
                else if (i == (nodes.size() - 1) && nodes.size() != 1)
                {
                    int beforeNodeId = nodes.get(i - 1).getId();
                    int afterNodeId = -2;
                    nodes.get(i).setBeforeNodeId(beforeNodeId);
                    nodes.get(i).setAfterNodeId(afterNodeId);
                    nodes.get(i).setVersion(version);
                    this.update(nodes.get(i));
                }
                else if (i == 0 && i == (nodes.size() - 1))
                {
                    int beforeNodeId = -1;
                    int afterNodeId = -2;
                    nodes.get(i).setBeforeNodeId(beforeNodeId);
                    nodes.get(i).setAfterNodeId(afterNodeId);
                    nodes.get(i).setVersion(version);
                    this.update(nodes.get(i));
                }
                else
                {
                    int beforeNodeId = nodes.get(i - 1).getId();
                    int afterNodeId = nodes.get(i + 1).getId();
                    nodes.get(i).setBeforeNodeId(beforeNodeId);
                    nodes.get(i).setAfterNodeId(afterNodeId);
                    nodes.get(i).setVersion(version);
                    this.update(nodes.get(i));
                }
            }
            MntProcessInfo process = (MntProcessInfo)this.findByPrimaryKey(MntProcessInfo.class, processId);
            process.setCanUse(1);
            this.update(process);
        }
        catch (Exception e)
        {
            e.printStackTrace();
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            return false;
        }
        return true;
    }
    
    @Override
    public int getNodeVersion(int processId)
    {
        int version = -1;
        final StringBuffer sql = new StringBuffer();
        sql.append(" SELECT IFNULL(MAX(version),-1) AS version");
        sql.append(" FROM mnt_nodeInfo");
        sql.append(" WHERE processId = ?");
        final Query query = this.getSession().createSQLQuery(sql.toString());
        query.setParameter(0, processId);
        query.setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP);
        final List<Map<String, Object>> list = query.list();
        for (Map<String, Object> map : list)
        {
            version = Integer.parseInt(map.get("version").toString());
        }
        return version;
    }
    
    @Override
    public List<Map<String, Object>> getUpdateNodes(int processId)
    {
        final StringBuffer sql = new StringBuffer();
        sql.append(" SELECT nodeName,roleId,sr.roleName");
        sql.append(" FROM mnt_nodeInfo mn");
        sql.append(" LEFT JOIN sys_role sr ON mn.roleId = sr.id");
        sql.append(" WHERE mn.processId = ?");
        sql.append(" AND mn.version = (");
        sql.append(" SELECT MAX(temp.version)");
        sql.append(" FROM mnt_nodeInfo temp");
        sql.append(" WHERE temp.processId = ?)");
        final Query query = this.getSession().createSQLQuery(sql.toString());
        query.setParameter(0, processId);
        query.setParameter(1, processId);
        query.setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP);
        return query.list();
    }
    
    @Override
    public PageUtil getServiceList(int orgId, PageInfo info)
    {
        final StringBuffer sql = new StringBuffer();
        sql.append(" SELECT pro.id AS proId,");
        sql.append(" pro.processName AS proName,");
        sql.append(" IFNULL(orgPro.id,'close') AS orgProId,");
        sql.append(" IFNULL(orgPro.flag,'close') AS flag");
        sql.append(" FROM mnt_processInfo pro");
        sql.append(" INNER JOIN mnt_member mMem ON mMem.id = pro.mngId");
        sql.append(" INNER JOIN mnt_mngandusers mmu ON mmu.mntMemberId = mMem.id AND mmu.state = 1");
        sql.append(" INNER JOIN biz_member bMem ON bMem.ID = mmu.userMemberId");
        sql.append(" INNER JOIN biz_organization org ON org.ownerId = bMem.ID AND org.enable = 1 AND org.ID = ?");
        sql.append(" LEFT JOIN mnt_orgProcessInfo orgPro ON orgPro.processId = pro.id AND orgPro.orgId = org.ID AND orgPro.flag = 1");
        sql.append(" WHERE pro.canUse = 1 AND pro.isDelete = 0");
        return this.findPageBySqlQuery(sql.toString(), info.getPage(), info.getRows(), orgId);
    }
    
    @Override
    public boolean saveService(MntOrgProcessInfo orgProcessInfo)
    {
        try
        {
            int version = this.getNodeVersion(orgProcessInfo.getProcessId());
            orgProcessInfo.setVersion(version);
            orgProcessInfo.setFlag(1);
            orgProcessInfo.setStamp(new Date());
            this.save(orgProcessInfo);
            int processId = orgProcessInfo.getProcessId();
            int orgId = orgProcessInfo.getOrgId();
            int orgProcessId = orgProcessInfo.getId();
            int currentNodeId = this.getInitNodeId(processId, version);
            MntOrgProcessHistory orgProcessHistory = new MntOrgProcessHistory();
            orgProcessHistory.setOrgId(orgId);
            orgProcessHistory.setOrgProcessId(orgProcessId);
            orgProcessHistory.setCurrentNodeId(currentNodeId);
            orgProcessHistory.setFlag(0);
            orgProcessHistory.setOrderSeq(0);
            orgProcessHistory.setBeginStamp(new Date());
            this.save(orgProcessHistory);
        }
        catch (Exception e)
        {
            e.printStackTrace();
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            return false;
        }
        return true;
    }
    
    @Override
    public Integer getInitNodeId(int processId, int version)
    {
        Integer initNodeId = null;
        final StringBuffer sql = new StringBuffer();
        sql.append(" SELECT id AS nodeId");
        sql.append(" FROM mnt_nodeInfo");
        sql.append(" WHERE processId = ?");
        sql.append(" AND version = ?");
        sql.append(" AND beforeNodeId = -1");
        final Query query = this.getSession().createSQLQuery(sql.toString());
        query.setParameter(0, processId);
        query.setParameter(1, version);
        query.setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP);
        List<Map<String, Object>> list = query.list();
        for (Map<String, Object> map : list)
        {
            initNodeId = Integer.parseInt(map.get("nodeId").toString());
        }
        return initNodeId;
    }
    
    @Override
    public boolean deleteService(int orgProcessId)
    {
        try
        {
            this.deleteByPrimaryKey(MntOrgProcessInfo.class, orgProcessId);
            this.deleteByProperty(MntOrgProcessHistory.class, "orgProcessId", Integer.toString(orgProcessId));
        }
        catch (Exception e)
        {
            e.printStackTrace();
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            return false;
        }
        return true;
    }
    
    @Override
    public Map<String, Object> getMainServiceInfo(boolean isAdmin, int memberId, List<Map<String, Object>> roleIdList, int mngId)
    {
        Map<String, Object> result = new HashMap<String, Object>();
        StringBuffer sql = new StringBuffer();
        sql.append(" SELECT");
        sql.append(" orgProHis.id AS ophId,");
        sql.append(" DATE_FORMAT(orgProHis.beginStamp, '%Y-%m-%d') AS stamp,");
        sql.append(" org. NAME AS orgName,");
        sql.append(" node.nodeName");
        sql.append(" FROM mnt_processInfo pro");
        sql.append(" INNER JOIN mnt_nodeInfo node ON node.processId = pro.id");
        sql.append(" INNER JOIN mnt_orgProcessInfo orgPro ON orgPro.processId = pro.id");
        sql.append(" INNER JOIN mnt_orgProcessHistory orgProHis ON orgProHis.orgProcessId = orgPro.id");
        sql.append(" AND orgProHis.currentNodeId = node.id");
        sql.append(" AND orgProHis.flag = 0");
        sql.append(" INNER JOIN biz_organization org ON org.id = orgPro.orgId");
        sql.append(" WHERE currentNodeId<>-2 AND pro.mngId = ?");
        if (!isAdmin)
        {
            String roleId = "'roleId'";
            for (Map<String, Object> map : roleIdList)
            {
                roleId = roleId + "," + map.get("roleID");
            }
            sql.append(" AND (node.roleId IN (" + roleId + ")");
            sql.append(" OR orgProHis.memberId = " + memberId + ")");
        }
        final Query query = this.getSession().createSQLQuery(sql.toString());
        query.setInteger(0, mngId);
        query.setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP);
        List<Map<String, Object>> list = query.list();
        int serTotal = list.size();
        result.put("serList", list);
        result.put("serTotal", serTotal);
        return result;
    }
    
    @Override
    public boolean updateService(int ophId, int creatorId, String creatorName)
    {
        try
        {
            MntOrgProcessHistory oldOph = (MntOrgProcessHistory)this.findByPrimaryKey(MntOrgProcessHistory.class, ophId);
            Map<String, Object> nodeInfo = this.getNextNodeInfo(oldOph.getCurrentNodeId());
            if (Integer.parseInt(nodeInfo.get("nodeId").toString()) == -2)
            {
                oldOph.setFlag(1);
                oldOph.setEndStamp(new Date());
                oldOph.setCreatorId(creatorId);
                oldOph.setCreatorName(creatorName);
                this.update(oldOph);
                int orgProId = oldOph.getOrgProcessId();
                MntOrgProcessInfo orgProcessInfo = (MntOrgProcessInfo)this.findByPrimaryKey(MntOrgProcessInfo.class, orgProId);
                orgProcessInfo.setFlag(0);
                this.update(orgProcessInfo);
                return true;
            }
            oldOph.setFlag(1);
            oldOph.setEndStamp(new Date());
            oldOph.setCreatorId(creatorId);
            oldOph.setCreatorName(creatorName);
            this.update(oldOph);
            MntOrgProcessHistory newOph = new MntOrgProcessHistory();
            newOph.setOrgId(oldOph.getOrgId());
            newOph.setCurrentNodeId(Integer.parseInt(nodeInfo.get("nodeId").toString()));
            newOph.setOrderSeq(Integer.parseInt(nodeInfo.get("orderSeq").toString()));
            newOph.setOrgProcessId(oldOph.getOrgProcessId());
            newOph.setFlag(0);
            newOph.setBeginStamp(new Date());
            this.save(newOph);
        }
        catch (Exception e)
        {
            e.printStackTrace();
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            return false;
        }
        return true;
    }
    
    @Override
    public Map<String, Object> getNextNodeInfo(int cNodeId)
    {
        final StringBuffer sql = new StringBuffer();
        sql.append(" SELECT afterNodeId AS nodeId");
        sql.append(" FROM mnt_nodeInfo");
        sql.append(" WHERE id = ?");
        final Query query = this.getSession().createSQLQuery(sql.toString());
        query.setParameter(0, cNodeId);
        query.setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP);
        Map<String, Object> map = (Map<String, Object>)query.uniqueResult();
        int aNodeId = Integer.parseInt(map.get("nodeId").toString());
        if (aNodeId == -2)
        {
            return map;
        }
        final StringBuffer sqlNext = new StringBuffer();
        sqlNext.append(" SELECT id AS nodeId,orderSeq");
        sqlNext.append(" FROM mnt_nodeInfo");
        sqlNext.append(" WHERE id = ?");
        final Query queryNext = this.getSession().createSQLQuery(sqlNext.toString());
        queryNext.setParameter(0, aNodeId);
        queryNext.setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP);
        Map<String, Object> mapNext = (Map<String, Object>)queryNext.uniqueResult();
        mapNext.put("nodeId", aNodeId);
        return mapNext;
    }
    
    @Override
    public PageUtil getMoreServiceInfo(boolean isAdmin, int memberId, List<Map<String, Object>> roleIdList, int mngId, String orgName, String stamp, String flag, PageInfo info)
    {
        final StringBuffer sql = new StringBuffer();
        sql.append(" SELECT");
        sql.append(" orgProHis.id AS ophId,");
        sql.append(" DATE_FORMAT(orgProHis.beginStamp, '%Y-%m-%d') AS stamp,");
        sql.append(" org.name AS orgName,");
        sql.append(" pro.processName AS proName,");
        sql.append(" node.nodeName,");
        sql.append(" orgProHis.flag,orgProHis.id AS opera");
        sql.append(" FROM mnt_processInfo pro");
        sql.append(" INNER JOIN mnt_nodeInfo node ON node.processId = pro.id");
        sql.append(" INNER JOIN mnt_orgProcessInfo orgPro ON orgPro.processId = pro.id");
        sql.append(" INNER JOIN mnt_orgProcessHistory orgProHis ON orgProHis.orgProcessId = orgPro.id");
        sql.append(" AND orgProHis.currentNodeId = node.id");
        sql.append(" INNER JOIN biz_organization org ON org.id = orgPro.orgId");
        sql.append(" WHERE pro.mngId = ?");
        if (!isAdmin)
        {
            String roleId = "'roleId'";
            for (Map<String, Object> map : roleIdList)
            {
                roleId = roleId + "," + map.get("roleID");
            }
            sql.append(" AND (node.roleId IN (" + roleId + ")");
            sql.append(" OR orgProHis.memberId = " + memberId + ")");
        }
        if (orgName != null && !"".equals(orgName))
        {
            sql.append(" AND org.name LIKE '%" + orgName + "%'");
        }
        if (stamp != null && !"".equals(stamp))
        {
            sql.append(" AND DATE_FORMAT(orgProHis.beginStamp, '%Y-%m-%d')='" + stamp + "'");
        }
        if (flag != null && !"".equals(flag))
        {
            sql.append(" AND orgProHis.flag ='" + flag + "'");
        }
        sql.append(" ORDER BY pro.id,node.id");
        return this.findPageBySqlQuery(sql.toString(), info.getPage(), info.getRows(), mngId);
    }
    
    @Override
    public List<Map<String, Object>> getOrgProNodeList(int orgProId)
    {
        final StringBuffer sql = new StringBuffer();
        sql.append(" SELECT");
        sql.append(" oph.id AS ophId,");
        sql.append(" oph.orgProcessId AS opId,");
        sql.append(" oph.orgId,");
        sql.append(" oph.currentNodeId AS cNodeId,");
        sql.append(" node.nodeName,");
        sql.append(" oph.orderSeq,");
        sql.append(" oph.flag,");
        sql.append(" DATE_FORMAT(oph.beginStamp, '%Y-%m-%d') AS bStamp,");
        sql.append(" DATE_FORMAT(oph.endStamp, '%Y-%m-%d') AS eStamp,");
        sql.append(" IFNULL(fb.id, 'no') AS fbId,");
        sql.append(" IFNULL(fb.score, '') AS score,");
        sql.append(" IFNULL(fb.detail, '') AS detail");
        sql.append(" FROM mnt_orgProcessHistory oph");
        sql.append(" INNER JOIN mnt_nodeInfo node ON node.id = oph.currentNodeId");
        sql.append(" LEFT JOIN mnt_feedBack fb ON fb.ophId = oph.id");
        sql.append(" WHERE oph.orgProcessId = ?");
        sql.append(" ORDER BY oph.orderSeq");
        final Query query = this.getSession().createSQLQuery(sql.toString());
        query.setParameter(0, orgProId);
        query.setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP);
        return query.list();
    }
    
    @Override
    public boolean updateServiceMember(String ophId, String memberId)
    {
        try
        {
            MntOrgProcessHistory orgProcessHistory = (MntOrgProcessHistory)this.findByPrimaryKey(MntOrgProcessHistory.class, Integer.parseInt(ophId));
            orgProcessHistory.setMemberId(Integer.parseInt(memberId));
            this.update(orgProcessHistory);
        }
        catch (Exception e)
        {
            e.printStackTrace();
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            return false;
        }
        return true;
    }
    
    @Override
    public boolean deleteProcessSoft(MntProcessInfo processInfo)
    {
        try
        {
            MntProcessInfo process = (MntProcessInfo)this.findByPrimaryKey(MntProcessInfo.class, processInfo.getId());
            process.setIsDelete(1);
            this.update(process);
        }
        catch (Exception e)
        {
            e.printStackTrace();
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            return false;
        }
        return true;
    }
    
    @Override
    public boolean createDefaultProcess(int mngId, String processName, List<Map<String, Object>> nodeInfo)
    {
        try
        {
            int orderSeq = 0;
            MntProcessInfo processInfo = new MntProcessInfo();
            processInfo.setProcessName(processName);
            this.saveProcess(mngId, processInfo);
            List<MntNodeInfo> nodes = new ArrayList<MntNodeInfo>();
            for (Map<String, Object> map : nodeInfo)
            {
                MntNodeInfo node = new MntNodeInfo();
                node.setNodeName(map.get("nodeName").toString());
                node.setRoleId(Integer.parseInt(map.get("roleId").toString()));
                node.setProcessId(processInfo.getId());
                node.setOrderSeq(orderSeq * 1000);
                nodes.add(node);
                orderSeq++;
            }
            this.saveNode(nodes);
        }
        catch (Exception e)
        {
            e.printStackTrace();
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            return false;
        }
        return true;
    }
    
}
